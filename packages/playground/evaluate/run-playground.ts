// keeping this all in one file so I can be cool like checker.ts
import { stackSize } from './determine-stack-size.js';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import tsvfs from '@typescript/vfs';
import ts from 'typescript';
import { writeFile, readdir, readFile } from 'fs/promises'
import { statSync, mkdirSync, readdirSync, unlinkSync } from 'fs'
import { Rome, Distribution } from '@biomejs/js-api';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const filenameFromCurrent = (current: number) => String(current).padStart(6, '0');

const initialConditions = {
  current: 0,
  incrementBy: 50,
  stopAt: 1_000_000,
}
/** TODO */
const isPerfBenchmarking = initialConditions.incrementBy === 1;
const resultsDirectory = join(__dirname, './results');
const statsDirectory = join(resultsDirectory, './stats');
const finalResultPath = join(resultsDirectory, 'results.ts')

/** the very first run is seeded from the playground, but the rest are autogenerated in the /results directory from there forward */
const startFilePath =
  initialConditions.current === 0
  ? join(__dirname, './playground.ts')
  : join(resultsDirectory, `results-${filenameFromCurrent(initialConditions.current - initialConditions.incrementBy)}.ts`);

interface RunStats {
  instantiations: number;
  types: number;
  symbols: number;
  identifiers: number;
  cache: Record<string, number>;
  filesCount: number;
  typeStringLength: number;
}

type ProgramTotals = Record<string, number | Totals>;

interface ProgramStats {
  programTime: number;
  stackSize: number;
  totals: ProgramTotals;
  runs: Runs;
}

type Runs = Record<number, RunInfo>;

interface RunInfo {
  stats: RunStats;
  time: Record<string, number>;
}

const runStats = (program: ts.Program, typeStringLength: number): RunStats => ({
  instantiations: program.getInstantiationCount(),
  types: program.getTypeCount(),
  symbols: program.getSymbolCount(),
  identifiers: program.getIdentifierCount(),
  cache: program.getRelationCacheSizes(),
  filesCount: program.getSourceFiles().length,
  typeStringLength,
  // files: program.getSourceFiles().map(file => file.fileName),
});

interface Totals {
  sum: number;
  sumPerInstruction: number;
  min: number;
  minPerInstruction: number;
  max: number;
  maxPerInstruction: number;
  avg: number;
  avgPerInstruction: number;
  stdev: number;
  values: number[]
}

const getTotal = (path: string[], runs: Runs): Record<string, Totals> => {
  const values = Object.values(runs).map(run => (run as unknown as any)[path[0]][path[1]]);
  const count = Object.keys(runs).map(id => Number(id)).reduce((acc, b) => Math.max(acc, b), 0);
  
  const sum = values.reduce((acc, b) => acc + b, 0);
  const sumPerInstruction = sum / initialConditions.incrementBy;
  const min = values.reduce((acc, b) => Math.min(acc, b), Infinity);
  const minPerInstruction = min / initialConditions.incrementBy;
  const max = values.reduce((acc, b) => Math.max(acc, b), -Infinity);
  const maxPerInstruction = max / initialConditions.incrementBy;
  const avg = sum / initialConditions.incrementBy;
  const avgPerInstruction = avg / count;
  const stdev = values.reduce((acc, value) => {
    const diff = value - avg;
    return acc + diff ** 2
  }, 0) / (initialConditions.incrementBy - 1);

  const unrounded = {
    sum,
    sumPerInstruction,
    min,
    minPerInstruction,
    max,
    maxPerInstruction,
    avg,
    avgPerInstruction,
    stdev,
  }
  const rounded = Object.fromEntries(
    Object.entries(unrounded).map(([key, value]) => [
      key,
      Math.round((value + Number.EPSILON) * 100) / 100
    ])
  );

  return {
    [path.join('.')]: {
      ...(rounded as typeof unrounded),
      values,
    }
  }
}

const programStats = async ({
  programTime,
}: Pick<ProgramStats, 'programTime'>): Promise<ProgramStats> => {
  const files = (await readdir(statsDirectory)).filter(file => file.startsWith('stats-') && file.endsWith(".json"));
  let runs: Runs = {};
  for (const file of await readdir(statsDirectory)) {
    if (!file.startsWith('stats-') || !file.endsWith(".json")) {
      console.log('skipping', file)
      continue;
    }

    const contents = await readFile(join(statsDirectory, file), 'utf-8');
    const parsed = JSON.parse(contents);
    const count = Number(file.match(/\d+/)?.[0]);
    runs[count] = parsed;
  }

  // min max avg stdev of each stat
  let totals = {
    ...getTotal(['time', 'getTypeAtLocation'], runs),
    ...getTotal(['time', 'typeToString'], runs),
    ...getTotal(['time', 'totalTime'], runs),
    ...getTotal(['stats', 'instantiations'], runs),
    ...getTotal(['stats', 'types'], runs),
    ...getTotal(['stats', 'symbols'], runs),
    ...getTotal(['stats', 'identifiers'], runs),
    ...getTotal(['stats', 'typeStringLength'], runs),
  }

  return {
    programTime,
    stackSize: stackSize(),
    totals,
    runs,
  }
}

/**
 * this "file" is mostly on one line and it can get sorta long, so it's good to break it up in a few places
 * e.g. if the string ` instructions: [` is detected, replace it with `\ninstructions: [`
 */
const preBreakFile = (text: string) => (
  text
    .replace(/ instructions: \[/g, '\ninstructions: [')
    .replace(/ activeExecutionContext: \{/g, '\nactiveExecutionContext: {')
    .replace(/ memory: \{/g, '\nmemory: {')
    .replace(/ executionContexts: \[/g, '\nmemory: [')
    .replace(/ funcs: \{/g, '\nfuncs: {')
);

const reportErrors = (program: ts.Program) => {
  ts.getPreEmitDiagnostics(program).forEach(diagnostic => {
    if (diagnostic.file) {
      let { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start!);
      let message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
      console.error(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
      console.log();
    } else {
      console.error(ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"));
      console.log();
    }

  });
}

interface ProgramRun {
  current: number;
  stopAt: number;
  incrementBy: number;
  targetFile: string;
  shouldWriteFile?: boolean;
}

const projectRoot = join(__dirname, '../../../');
const globalDefinitions = join(__dirname, '../../../global.d.ts');
const tsconfigFilePath = join(projectRoot, './tsconfig.json');

const configFile = ts.readConfigFile(tsconfigFilePath, ts.sys.readFile)
const { options } = ts.parseJsonConfigFileContent(
  configFile.config,
  ts.sys,
  dirname(tsconfigFilePath)
);

const libFiles = tsvfs.createDefaultMapFromNodeModules(options);

const isolatedProgram = async ({
  current,
  stopAt,
  incrementBy,
  targetFile,
  shouldWriteFile = process.argv.includes('--write-file'),
}: ProgramRun): Promise<void | ProgramRun> => {
  /** this is the magic type alias that the script is looking for in the targetFile */
  const targetTypeAlias = 'Evaluate';

  const system = tsvfs.createFSBackedSystem(
    libFiles,
    projectRoot,
    ts
  )

  const env = tsvfs.createVirtualTypeScriptEnvironment(
    system,
    [targetFile, globalDefinitions],
    ts,
    options
  )

  const startProgram = performance.now();
  const program = env?.languageService.getProgram()!
  const endProgram = performance.now();

  const startTargetSourceFile = performance.now();
  const targetSourceFile = program.getSourceFile(targetFile)!;
  const endTargetSourceFile = performance.now();

  const startGetTypeAlias = performance.now();
  let typeAlias: ts.TypeAliasDeclaration;
  ts.forEachChild(targetSourceFile, node => {
    if (ts.isTypeAliasDeclaration(node) && node.name.escapedText === targetTypeAlias) {
      typeAlias = node;
    }
  });
  const endTypeAlias = performance.now();

  const startChecker = performance.now();
  const checker = program.getTypeChecker();
  const endChecker = performance.now();

  const startType = performance.now();
  const type = checker.getTypeAtLocation(typeAlias!); // this is the line that matters
  const endType = performance.now();

  const startTypeString = performance.now();
  const typeString = checker.typeToString(type);
  const endTypeString = performance.now();
  const typeStringLength = typeString.length;

  const time = {
    programTime: endProgram - startProgram,
    getSourceFileTime: endTargetSourceFile - startTargetSourceFile,
    getTypeAliasTime: endTypeAlias - startGetTypeAlias,
    checkerTime: endChecker - startChecker,
    getTypeAtLocation: endType - startType,
    typeToString: endTypeString - startTypeString,
    totalTime: endTypeString - startProgram,
  };

  const stats = runStats(program, typeStringLength);

  const isComplete = typeString.length < 100;
  const updatedStopAt = current + incrementBy;

  if (!isComplete) {
    shortStats(current, time.getTypeAtLocation, stats.instantiations, typeStringLength);
  }
  reportErrors(program);

  if (!shouldWriteFile) {
    console.log();
    console.log(typeString.replaceAll('\\n', '\n'));
    return;
  }

  if (isComplete) {
    await finalizeProgram(typeString, updatedStopAt, current, incrementBy, stopAt);
    return;
  }

  const formattedCurrent = filenameFromCurrent(current);
  const statsJsonPath = join(statsDirectory, `stats-${formattedCurrent}.json`);
  await writeFile(statsJsonPath, JSON.stringify({ time, stats }, null, 2), 'utf-8');

  const programImport = `import { executeInstruction } from '../../../wasm-to-typescript-types/program'\n`
  const typeName = `PlaygroundResult_${formattedCurrent}`;
  let playgroundResult = `export type ${typeName} = ${typeString}`;
  const evaluate = preBreakFile(`export type Evaluate = executeInstruction<${typeName}, false, ${updatedStopAt}>`)

  const unformattedFile = [
    programImport,
    evaluate,
    playgroundResult,
  ].join('\n\n');

  const {
    content: formattedFile,
    diagnostics: formatterDiagnositcs
  } = rome.formatContent(unformattedFile, {
    filePath: targetFile,
  });

  if (formatterDiagnositcs.length) {
    console.error('diagnostics from formatter', formatterDiagnositcs);
    return;
  }

  const nextFilePath = join(resultsDirectory, `results-${formattedCurrent}.ts`)
  await writeFile(nextFilePath, formattedFile, 'utf-8');

  // const extractedCount = count ? Number(count[0].match(/\d+/)?.[0]) : 0;
  const match = formattedFile.match(/\tcount: (\d+);/);
  const actualCount = Number(match?.[1]);

  const foundErrors = formattedFile.includes('never');

  if (foundErrors) {
    console.error(`stopped because errors found in the file (search ${nextFilePath} for "never")`);
    return;
  }

  if (actualCount > current) {
    console.log('naturally reached the end of the program at instruction count', actualCount);
    return;
  }

  if (stopAt > 0 && updatedStopAt >= stopAt) {
    console.log('stopped because we reached the stopAt instruction count', stopAt);
    return;
  }

  if (current < stopAt) {
    return {
      current: current + incrementBy,
      stopAt,
      incrementBy,
      targetFile: nextFilePath
    };
  }
}

// TODO, improve the signature here
const finalizeProgram = async (
  typeString: string,
  updatedStopAt: number,
  current: number,
  incrementBy: number,
  stopAt: number,
) => {
  const maybeResult = +typeString;
  // the program seems to have reached the end
  if (isNaN(maybeResult)) {
    console.error('the program has reached the end, but the result is not a number');
    console.error(maybeResult);
    return;
  }
  const previous = filenameFromCurrent(current - incrementBy);
  const file = [
  `import { ReadStringFromMemory } from '../../../ts-type-math';`,
  `import { executeInstruction } from '../../../wasm-to-typescript-types/program';`,
  `import { PlaygroundResult_${previous} } from './results-${previous}';`,
  ``,
  `type e = executeInstruction<PlaygroundResult_${previous}, true>`,
  `type Evaluate = ReadStringFromMemory<e>`,
  '//   ^?',
  '',
  '// made by Dimitri Mitropoulos and Michigan TypeScript',
  '//',
  '// > we owe a lot to the TypeScript team for making this possible and being such a great team.',
  '',
  ].join('\n');
  await writeFile(finalResultPath, file, 'utf-8');

  await isolatedProgram({
    current: updatedStopAt,
    stopAt,
    incrementBy,
    targetFile: finalResultPath,
    shouldWriteFile: false,
  });
  console.log();
}

const shortStats = (
  count: number,
  getTypeAtLocation: number,
  instantiations: number,
  typeStringLength: number
) => {
  // you see.. when you console.log a number it shows it in orange.  so we're going through some extra trouble to keep it that way
  const roundedCount = Math.round(count)
  const countFiller = ' '.repeat(Math.max(0, 6 - roundedCount.toString().length));
  const roundedGTAL = Math.round(getTypeAtLocation);
  const gTALFiller = ' '.repeat(Math.max(0, 7 - roundedGTAL.toString().length));
  const roundedInstantiations = Math.round(instantiations);
  const instFiller = ' '.repeat(Math.max(0, 10 - roundedInstantiations.toString().length));
  const roundedLength = Math.round(typeStringLength);
  const lenFiller = ' '.repeat(Math.max(0, 7 - roundedLength.toString().length));
  console.log(
    `count${countFiller}`,
    roundedCount,
    ` | time (ms)${gTALFiller}`,
    roundedGTAL,
    ` | instantiations${instFiller}`,
    roundedInstantiations,
    ` | length${lenFiller}`,
    roundedLength,
  );
}

const clearResultsDirectory = () => {
  if (initialConditions.current != 0) {
    // skip clearing the results directory if we're not starting from scratch
    return;
  }

  try {
    statSync(statsDirectory);
    const files = readdirSync(statsDirectory);
    for (const file of files) {
      unlinkSync(join(statsDirectory, file));
    }
  } catch (e) {
    if ((e as unknown as any).code === 'ENOENT') {
      // if the directory doesn't exist, create it
      mkdirSync(statsDirectory);
    }
  }

  // delete the results directory and recreate it
  try {
    statSync(resultsDirectory);
    const files = readdirSync(resultsDirectory);
    for (const file of files) {
      unlinkSync(join(resultsDirectory, file));
    }
  } catch (e) {
    if ((e as unknown as any).code === 'ENOENT') {
      // if the directory doesn't exist, create it
      mkdirSync(resultsDirectory);
    }
  }
}

const encourage = () => {
  const phrases = [
    "Expecto Patronum!",
    "Here's to escaping the Sarlacc pit.",
    "May your mana *cough cough* err. recursion limit.. never run out",
    "Achieve victory and return with honor",
    "You're probably going to need a bigger boat",
    "You're off to great places, today is your day!",
    "The truth is out there",
    "Are you tryna create a union that's too complex to represent.. again?",
    "I always trusted code more than people anyway.",
    "To excessive and possibly infinite depth and beyond!", // credit: DBlass
    "10 bucks says what comes next starts with \"RangeError: Maximum call stack size exceeded at `instantiateTypes`\"",
  ]
  
  console.log(phrases[Math.floor(Math.random() * phrases.length)]);
  console.log();
}

const rome = await Rome.create({
  distribution: Distribution.NODE,
});
rome.applyConfiguration({
    // @ts-ignore there's a problem with the biome js-api.  there's also a pnpm patch to fix this
    gitignore_matches: [],
    files: {
      maxSize: 1024 * 1024 * 1024,
  }
})

encourage();
const startProgram = performance.now();
clearResultsDirectory();

let runConfig: ProgramRun | void = {
  current: initialConditions.current,
  stopAt: initialConditions.stopAt,
  incrementBy: initialConditions.incrementBy,
  targetFile: startFilePath,
};


while (true) {
  runConfig = await isolatedProgram(runConfig);
  if (!runConfig) {
    break;
  }
}

const endProgram = performance.now();
const programTime = endProgram - startProgram;

const writeProgramStats = async (programTime: number) => {
  const stats = await programStats({ programTime });
  
  console.log("total time (ms)", Math.round(programTime));
  
  const statsPath = join(statsDirectory, 'program-stats.json');
  await writeFile(statsPath, JSON.stringify(stats, null, 2), 'utf-8');
  console.log(`wrote program stats to ${statsPath}`);
}

await writeProgramStats(programTime);

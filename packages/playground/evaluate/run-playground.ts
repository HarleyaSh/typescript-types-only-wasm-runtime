import { stackSize } from './determine-stack-size.js';
import { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';
import tsvfs from '@typescript/vfs';
import ts from 'typescript';
import { readdirSync, stat, unlinkSync, writeFileSync } from 'fs';
import { Rome, Distribution } from '@biomejs/js-api';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const filenameFromCurrent = (current: number) => String(current).padStart(6, '0');

const initialConditions = {
  current: 0,
  incrementBy: 50,
  stopAt: 1_000_000,
}
const resultsDirectory = resolve(__dirname, './results');
const finalResultPath = resolve(resultsDirectory, 'results.ts')

/** the very first run is seeded from the playground, but the rest are autogenerated in the /results directory from there forward */
const startFilePath =
  initialConditions.current === 0
  ? resolve(__dirname, './playground.ts')
  : resolve(resultsDirectory, `results-${filenameFromCurrent(initialConditions.current - initialConditions.incrementBy)}.ts`);

interface RunStats {
  instantiations: number;
  types: number;
  symbols: number;
  identifiers: number;
  cache: Record<string, number>;
  filesCount: number;
  typeStringLength: number;
}

type ProgramTotals = Record<string, number | Totals>;

interface ProgramStats {
  programTime: number;
  stackSize: number;
  totals: ProgramTotals;
  runs: Runs;
}

type Runs = Record<number, RunInfo>;

interface RunInfo {
  stats: RunStats;
  time: Record<string, number>;
}

const runStats = (program: ts.Program, typeStringLength: number): RunStats => ({
  instantiations: program.getInstantiationCount(),
  types: program.getTypeCount(),
  symbols: program.getSymbolCount(),
  identifiers: program.getIdentifierCount(),
  cache: program.getRelationCacheSizes(),
  filesCount: program.getSourceFiles().length,
  typeStringLength,
  // files: program.getSourceFiles().map(file => file.fileName),
});

interface Totals {
  sum: number;
  min: number;
  max: number;
  avg: number;
  stdev: number;
}

const getTotal = (path: string[], runs: Runs): Record<string, Totals> => {
  const values = Object.values(runs).map(run => (run as unknown as any)[path[0]][path[1]]);
  const sum = values.reduce((acc, b) => acc + b, 0);
  const min = values.reduce((acc, b) => Math.min(acc, b), 0);
  const max = values.reduce((acc, b) => Math.max(acc, b), 0);
  const avg = values.reduce((acc, b) => acc + b, 0) / values.length;
  const stdev = values.reduce((acc, value) => {
    const diff = value - avg;
    return acc + diff ** 2
  }, 0) / (values.length - 1);

  return {
    [path.join('.')]: {
      sum,
      min,
      max,
      avg,
      stdev,
    }
  }
}

const programStats = ({
  programTime,
}: Pick<ProgramStats, 'programTime'>): ProgramStats => {
  // get every file that starts with `results-` and ends with `.ts`
  const files = readdirSync(resultsDirectory).filter(file => file.startsWith('results-'));

  // extract the javascript object starting with stats_ from each file
  // const runs = files.reduce((acc, file) => {
  //   const path = resolve(resultsDirectory, file);
  //   const text = readFileSync(path, 'utf-8');
  //   const match = text.match(/export const stats_(\d+) = ({[^]*})/);
  //   if (!match) {
  //     console.error('no match found in', path);
  //     return acc;
  //   }
  
  // TODO: go through each file and find all the stats and compile them here into a single object
  let runs: Runs = {};

  // min max avg stdev of each stat
  let totals = {
    // TODO, figure out how to get total instruction count in here
    // instructions: getTotal(['stats', 'instructions'], runs)['instructions'].sum,

    ...getTotal(['stats', 'types'], runs),
    ...getTotal(['stats', 'instantiations'], runs),
    ...getTotal(['stats', 'types'], runs),
    ...getTotal(['stats', 'length'], runs),
  }

  return {
    programTime,
    stackSize: stackSize(),
    totals,
    runs,
  }
}

/**
 * this "file" is mostly on one line and it can get sorta long, so it's good to break it up in a few places
 * e.g. if the string ` instructions: [` is detected, replace it with `\ninstructions: [`
 */
const preBreakFile = (text: string) => (
  text
    .replace(/ instructions: \[/g, '\ninstructions: [')
    .replace(/ activeExecutionContext: \{/g, '\nactiveExecutionContext: {')
    .replace(/ memory: \{/g, '\nmemory: {')
    .replace(/ executionContexts: \[/g, '\nmemory: [')
    .replace(/ funcs: \{/g, '\nfuncs: {')
);

const reportErrors = (program: ts.Program) => {
  ts.getPreEmitDiagnostics(program).forEach(diagnostic => {
    if (diagnostic.file) {
      let { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start!);
      let message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
      console.error(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
      console.log();
    } else {
      console.error(ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"));
      console.log();
    }

  });
}

interface ProgramRun {
  current: number;
  stopAt: number;
  incrementBy: number;
  targetFile: string;
  writeFile?: boolean;
}

const isolatedProgram = async ({
  current,
  stopAt,
  incrementBy,
  targetFile,
  writeFile = process.argv.includes('--write-file'),
}: ProgramRun): Promise<void | ProgramRun> => {
  const projectRoot = resolve(__dirname, '../../../');
  const globalDefinitions = resolve(__dirname, '../../../global.d.ts');
  const tsconfigFilePath = resolve(projectRoot, './tsconfig.json');

  /** this is the magic type alias that the script is looking for in the targetFile */
  const targetTypeAlias = 'Evaluate';

  const configFile = ts.readConfigFile(tsconfigFilePath, ts.sys.readFile)
  const { options } = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    dirname(tsconfigFilePath)
  );

  const libFiles = tsvfs.createDefaultMapFromNodeModules(options);
  const system = tsvfs.createFSBackedSystem(
    libFiles,
    projectRoot,
    ts
  )
  const env = tsvfs.createVirtualTypeScriptEnvironment(
    system,
    [targetFile, globalDefinitions],
    ts,
    options
  )

  const startProgram = performance.now();
  const program = env?.languageService.getProgram()!
  const endProgram = performance.now();

  const startTargetSourceFile = performance.now();
  const targetSourceFile = program.getSourceFile(targetFile)!;
  const endTargetSourceFile = performance.now();

  const startGetTypeAlias = performance.now();
  let typeAlias: ts.TypeAliasDeclaration;
  ts.forEachChild(targetSourceFile, node => {
    if (ts.isTypeAliasDeclaration(node) && node.name.escapedText === targetTypeAlias) {
      typeAlias = node;
    }
  });
  const endTypeAlias = performance.now();

  const startChecker = performance.now();
  const checker = program.getTypeChecker();
  const endChecker = performance.now();

  const startType = performance.now();
  const type = checker.getTypeAtLocation(typeAlias!); // this is the line that matters
  const endType = performance.now();

  const startTypeString = performance.now();
  const typeString = checker.typeToString(type);
  const endTypeString = performance.now();
  const typeStringLength = typeString.length;

  const time = {
    programTime: Math.round(Number(endProgram - startProgram)),
    getSourceFileTime: Math.round(Number(endTargetSourceFile - startTargetSourceFile)),
    getTypeAliasTime: Math.round(Number(endTypeAlias - startGetTypeAlias)),
    checkerTime: Math.round(Number(endChecker - startChecker)),
    getTypeAtLocation: Math.round(Number(endType - startType)),
    typeToString: Math.round(Number(endTypeString - startTypeString)),
    totalTime: Math.round(Number(endTypeString - startProgram)),
  };

  const stats = runStats(program, typeStringLength);

  const isComplete = typeString.length < 100;
  const updatedStopAt = current + incrementBy;

  if (!isComplete) {
    shortStats(current, time.getTypeAtLocation, stats.instantiations, typeStringLength);
  }
  reportErrors(program);

  if (!writeFile) {
    console.log();
    console.log(typeString.replaceAll('\\n', '\n'));
    return;
  }

  if (isComplete) {
    await finalizeProgram(typeString, updatedStopAt, current, incrementBy, stopAt);
    return;
  }

  const formattedCurrent = filenameFromCurrent(current);

  const programImport = `import { executeInstruction } from '../../../wasm-to-typescript-types/program'\n`

  // TODO consider dumping to separate JSON file
  const statsString = `export const stats_${formattedCurrent} = ${JSON.stringify({ time, stats }, null, 2)}`
  const typeName = `PlaygroundResult_${formattedCurrent}`;
  let playgroundResult = `export type ${typeName} = ${typeString}`;
  const evaluate = preBreakFile(`export type Evaluate = executeInstruction<${typeName}, false, ${updatedStopAt}>`)


  const unformattedFile = [
    programImport,
    statsString,
    evaluate,
    playgroundResult,
  ].join('\n\n');

  const {
    content: formattedFile,
    diagnostics: formatterDiagnositcs
  } = rome.formatContent(unformattedFile, {
    filePath: targetFile,
  });

  if (formatterDiagnositcs.length) {
    console.error('diagnostics from formatter', formatterDiagnositcs);
    return;
  }

  const nextFilePath = resolve(__dirname, `./results/results-${formattedCurrent}.ts`)
  writeFileSync(nextFilePath, formattedFile, 'utf-8');

  // const extractedCount = count ? Number(count[0].match(/\d+/)?.[0]) : 0;
  const match = formattedFile.match(/\tcount: (\d+);/);
  const actualCount = Number(match?.[1]);

  const foundErrors = formattedFile.includes('never');

  if (foundErrors) {
    console.error(`stopped because errors found in the file (search ${nextFilePath} for "never")`);
    return;
  }

  if (actualCount > current) {
    console.log('naturally reached the end of the program at instruction count', actualCount);
    return;
  }

  if (stopAt > 0 && updatedStopAt >= stopAt) {
    console.log('stopped because we reached the stopAt instruction count', stopAt);
    return;
  }

  if (current < stopAt) {
    return {
      current: current + incrementBy,
      stopAt,
      incrementBy,
      targetFile: nextFilePath
    };
  }
}

// TODO, improve the signature here
const finalizeProgram = async (
  typeString: string,
  updatedStopAt: number,
  current: number,
  incrementBy: number,
  stopAt: number,
) => {
  const maybeResult = +typeString;
  // the program seems to have reached the end
  if (isNaN(maybeResult)) {
    console.error('the program has reached the end, but the result is not a number');
    console.error(maybeResult);
    return;
  }
  const previous = filenameFromCurrent(current - incrementBy);
  const file = [
  `import { ReadStringFromMemory } from '../../../ts-type-math';`,
  `import { executeInstruction } from '../../../wasm-to-typescript-types/program';`,
  `import { PlaygroundResult_${previous} } from './results-${previous}';`,
  ``,
  `type e = executeInstruction<PlaygroundResult_${previous}, true>`,
  `type Evaluate = ReadStringFromMemory<e>`,
  '//   ^?',
  '',
  '// made by Dimitri Mitropoulos and Michigan TypeScript',
  '//',
  '// > we owe a lot to the TypeScript team for making this possible and being such a great team.',
  '',
  ].join('\n');
  writeFileSync(finalResultPath, file, 'utf-8');

  await isolatedProgram({
    current: updatedStopAt,
    stopAt,
    incrementBy,
    targetFile: finalResultPath,
    writeFile: false,
  });
  console.log();
}

const shortStats = (
  count: number,
  getTypeAtLocation: number,
  instantiations: number,
  typeStringLength: number
) => {
  // you see.. when you console.log a number it shows it in orange.  so we're going through some extra trouble to keep it that way
  const countFiller = ' '.repeat(Math.max(0, 6 - count.toString().length));
  const gTALFiller = ' '.repeat(Math.max(0, 6 - getTypeAtLocation.toString().length));
  const instFiller = ' '.repeat(Math.max(0, 10 - instantiations.toString().length));
  const lenFiller = ' '.repeat(Math.max(0, 7 - typeStringLength.toString().length));
  console.log(
    `count${countFiller}`,
    count,
    ` | time (ms)${gTALFiller}`,
    getTypeAtLocation,
    ` | instantiations${instFiller}`,
    instantiations,
    ` | length${lenFiller}`,
    typeStringLength
  );
}

const clearResultsDirectory = () => {
  if (initialConditions.current != 0) {
    // skip clearing the results directory if we're not starting from scratch
    return;
  }

  // delete every file in the results directory
  const resultsDirectory = resolve(__dirname, './results');
  const files = readdirSync(resultsDirectory);
  files.forEach(file => {
    unlinkSync(resolve(resultsDirectory, file));
  });
}

const encourage = () => {
  const phrases = [
    "Expecto Patronum!",
    "Here's to escaping the Sarlacc pit.",
    "May your mana *cough cough* err. recursion limit.. never run out",
    "Achieve victory and return with honor",
    "You're probably going to need a bigger boat",
    "You're off to great places, today is your day!",
    "The truth is out there",
    "Are you tryna create a union that's too complex to represent.. again?",
    "I always trusted code more than people anyway.",
    "To excessive and possibly infinite depth and beyond!", // credit: DBlass
    "10 bucks says what comes next starts with \"RangeError: Maximum call stack size exceeded at `instantiateTypes`\"",
  ]
  
  console.log(phrases[Math.floor(Math.random() * phrases.length)]);
  console.log();
}

const rome = await Rome.create({
  distribution: Distribution.NODE,
});
rome.applyConfiguration({
    // @ts-ignore there's a problem with the biome js-api.  there's also a pnpm patch to fix this
    gitignore_matches: [],
    files: {
      maxSize: 1024 * 1024 * 1024,
  }
})

encourage();
const startProgram = performance.now();
clearResultsDirectory();

let runConfig: ProgramRun | void = {
  current: initialConditions.current,
  stopAt: initialConditions.stopAt,
  incrementBy: initialConditions.incrementBy,
  targetFile: startFilePath,
};


while (true) {
  runConfig = await isolatedProgram(runConfig);
  if (!runConfig) {
    break;
  }
}

const endProgram = performance.now();
const programTime = Math.round(endProgram - startProgram);

const writeProgramStats = (programTime: number) => {
  const program = programStats({ programTime });
  
  console.log("total time (ms)", Math.round(endProgram - startProgram));
  
  const statsPath = './results/program-stats.json';
  writeFileSync(
    resolve(__dirname, statsPath),
    JSON.stringify(program, null, 2),
    'utf-8'
  );
  console.log(`wrote program stats to ${statsPath}`);
}

writeProgramStats(programTime);
